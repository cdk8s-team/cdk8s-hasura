// generated by cdk8s // and duplicates were removed manually.
// @see docs/issues.md
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';

/**
 *
 *
 * @schema postgresql
 */
export class Postgresql extends ApiObject {
  /**
   * Returns the apiVersion and kind for "postgresql"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acid.zalan.do/v1',
    kind: 'postgresql',
  };

  /**
   * Renders a Kubernetes manifest for "postgresql".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PostgresqlProps): any {
    return {
      ...Postgresql.GVK,
      ...toJson_PostgresqlProps(props),
    };
  }

  /**
   * Defines a "postgresql" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PostgresqlProps) {
    super(scope, id, {
      ...Postgresql.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Postgresql.GVK,
      ...toJson_PostgresqlProps(resolved),
    };
  }
}

/**
 * @schema postgresql
 */
export interface PostgresqlProps {
  /**
   * @schema postgresql#spec
   */
  readonly spec: PostgresqlSpec;

  /**
   * @schema postgresql#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'PostgresqlProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlProps(
  obj: PostgresqlProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_PostgresqlSpec(obj.spec),
    metadata: obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpec
 */
export interface PostgresqlSpec {
  /**
   * @schema PostgresqlSpec#additionalVolumes
   */
  readonly additionalVolumes?: PostgresqlSpecAdditionalVolumes[];

  /**
   * @schema PostgresqlSpec#allowedSourceRanges
   */
  readonly allowedSourceRanges?: string[];

  /**
   * @schema PostgresqlSpec#clone
   */
  readonly clone?: PostgresqlSpecClone;

  /**
   * @schema PostgresqlSpec#connectionPooler
   */
  readonly connectionPooler?: PostgresqlSpecConnectionPooler;

  /**
   * @schema PostgresqlSpec#databases
   */
  readonly databases?: { [key: string]: string };

  /**
   * @schema PostgresqlSpec#dockerImage
   */
  readonly dockerImage?: string;

  /**
   * @schema PostgresqlSpec#enableConnectionPooler
   */
  readonly enableConnectionPooler?: boolean;

  /**
   * @schema PostgresqlSpec#enableReplicaConnectionPooler
   */
  readonly enableReplicaConnectionPooler?: boolean;

  /**
   * @schema PostgresqlSpec#enableLogicalBackup
   */
  readonly enableLogicalBackup?: boolean;

  /**
   * @schema PostgresqlSpec#enableMasterLoadBalancer
   */
  readonly enableMasterLoadBalancer?: boolean;

  /**
   * @schema PostgresqlSpec#enableMasterPoolerLoadBalancer
   */
  readonly enableMasterPoolerLoadBalancer?: boolean;

  /**
   * @schema PostgresqlSpec#enableReplicaLoadBalancer
   */
  readonly enableReplicaLoadBalancer?: boolean;

  /**
   * @schema PostgresqlSpec#enableReplicaPoolerLoadBalancer
   */
  readonly enableReplicaPoolerLoadBalancer?: boolean;

  /**
   * @schema PostgresqlSpec#enableShmVolume
   */
  readonly enableShmVolume?: boolean;

  /**
   * @schema PostgresqlSpec#env
   */
  readonly env?: any[];

  /**
   * @schema PostgresqlSpec#initContainers
   */
  readonly initContainers?: any[];

  /**
   * @schema PostgresqlSpec#logicalBackupSchedule
   */
  readonly logicalBackupSchedule?: string;

  /**
   * @schema PostgresqlSpec#maintenanceWindows
   */
  readonly maintenanceWindows?: string[];

  /**
   * @schema PostgresqlSpec#nodeAffinity
   */
  readonly nodeAffinity?: PostgresqlSpecNodeAffinity;

  /**
   * @schema PostgresqlSpec#numberOfInstances
   */
  readonly numberOfInstances: number;

  /**
   * @schema PostgresqlSpec#patroni
   */
  readonly patroni?: PostgresqlSpecPatroni;

  /**
   * @schema PostgresqlSpec#podAnnotations
   */
  readonly podAnnotations?: { [key: string]: string };

  /**
   * @schema PostgresqlSpec#podPriorityClassName
   */
  readonly podPriorityClassName?: string;

  /**
   * @schema PostgresqlSpec#postgresql
   */
  readonly postgresql: PostgresqlSpecPostgresql;

  /**
   * @schema PostgresqlSpec#preparedDatabases
   */
  readonly preparedDatabases?: {
    [key: string]: PostgresqlSpecPreparedDatabases;
  };

  /**
   * deprecated
   *
   * @schema PostgresqlSpec#replicaLoadBalancer
   */
  readonly replicaLoadBalancer?: boolean;

  /**
   * @schema PostgresqlSpec#resources
   */
  readonly resources?: PostgresqlSpecResources;

  /**
   * @schema PostgresqlSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * @schema PostgresqlSpec#serviceAnnotations
   */
  readonly serviceAnnotations?: { [key: string]: string };

  /**
   * @schema PostgresqlSpec#sidecars
   */
  readonly sidecars?: any[];

  /**
   * @schema PostgresqlSpec#spiloRunAsUser
   */
  readonly spiloRunAsUser?: number;

  /**
   * @schema PostgresqlSpec#spiloRunAsGroup
   */
  readonly spiloRunAsGroup?: number;

  /**
   * @schema PostgresqlSpec#spiloFSGroup
   */
  readonly spiloFsGroup?: number;

  /**
   * @schema PostgresqlSpec#standby
   */
  readonly standby?: PostgresqlSpecStandby;

  /**
   * @schema PostgresqlSpec#streams
   */
  readonly streams?: PostgresqlSpecStreams[];

  /**
   * @schema PostgresqlSpec#teamId
   */
  readonly teamId: string;

  /**
   * @schema PostgresqlSpec#tls
   */
  readonly tls?: PostgresqlSpecTls;

  /**
   * @schema PostgresqlSpec#tolerations
   */
  readonly tolerations?: PostgresqlSpecTolerations[];

  /**
   * deprecated
   *
   * @schema PostgresqlSpec#useLoadBalancer
   */
  readonly useLoadBalancer?: boolean;

  /**
   * @schema PostgresqlSpec#users
   */
  readonly users?: { [key: string]: PostgresqlSpecUsers[] };

  /**
   * @schema PostgresqlSpec#usersWithInPlaceSecretRotation
   */
  readonly usersWithInPlaceSecretRotation?: string[];

  /**
   * @schema PostgresqlSpec#usersWithSecretRotation
   */
  readonly usersWithSecretRotation?: string[];

  /**
   * @schema PostgresqlSpec#volume
   */
  readonly volume: PostgresqlSpecVolume;
}

/**
 * Converts an object of type 'PostgresqlSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpec(
  obj: PostgresqlSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    additionalVolumes: obj.additionalVolumes?.map((y) =>
      toJson_PostgresqlSpecAdditionalVolumes(y),
    ),
    allowedSourceRanges: obj.allowedSourceRanges?.map((y) => y),
    clone: toJson_PostgresqlSpecClone(obj.clone),
    connectionPooler: toJson_PostgresqlSpecConnectionPooler(
      obj.connectionPooler,
    ),
    databases:
      obj.databases === undefined
        ? undefined
        : Object.entries(obj.databases).reduce(
          (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
          {},
        ),
    dockerImage: obj.dockerImage,
    enableConnectionPooler: obj.enableConnectionPooler,
    enableReplicaConnectionPooler: obj.enableReplicaConnectionPooler,
    enableLogicalBackup: obj.enableLogicalBackup,
    enableMasterLoadBalancer: obj.enableMasterLoadBalancer,
    enableMasterPoolerLoadBalancer: obj.enableMasterPoolerLoadBalancer,
    enableReplicaLoadBalancer: obj.enableReplicaLoadBalancer,
    enableReplicaPoolerLoadBalancer: obj.enableReplicaPoolerLoadBalancer,
    enableShmVolume: obj.enableShmVolume,
    env: obj.env?.map((y) => y),
    init_containers: obj.initContainers?.map((y) => y),
    initContainers: obj.initContainers?.map((y) => y),
    logicalBackupSchedule: obj.logicalBackupSchedule,
    maintenanceWindows: obj.maintenanceWindows?.map((y) => y),
    nodeAffinity: toJson_PostgresqlSpecNodeAffinity(obj.nodeAffinity),
    numberOfInstances: obj.numberOfInstances,
    patroni: toJson_PostgresqlSpecPatroni(obj.patroni),
    podAnnotations:
      obj.podAnnotations === undefined
        ? undefined
        : Object.entries(obj.podAnnotations).reduce(
          (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
          {},
        ),
    pod_priority_class_name: obj.podPriorityClassName,
    podPriorityClassName: obj.podPriorityClassName,
    postgresql: toJson_PostgresqlSpecPostgresql(obj.postgresql),
    preparedDatabases:
      obj.preparedDatabases === undefined
        ? undefined
        : Object.entries(obj.preparedDatabases).reduce(
          (r, i) =>
            i[1] === undefined
              ? r
              : {
                ...r,
                [i[0]]: toJson_PostgresqlSpecPreparedDatabases(i[1]),
              },
          {},
        ),
    replicaLoadBalancer: obj.replicaLoadBalancer,
    resources: toJson_PostgresqlSpecResources(obj.resources),
    schedulerName: obj.schedulerName,
    serviceAnnotations:
      obj.serviceAnnotations === undefined
        ? undefined
        : Object.entries(obj.serviceAnnotations).reduce(
          (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
          {},
        ),
    sidecars: obj.sidecars?.map((y) => y),
    spiloRunAsUser: obj.spiloRunAsUser,
    spiloRunAsGroup: obj.spiloRunAsGroup,
    spiloFSGroup: obj.spiloFsGroup,
    standby: toJson_PostgresqlSpecStandby(obj.standby),
    streams: obj.streams?.map((y) => toJson_PostgresqlSpecStreams(y)),
    teamId: obj.teamId,
    tls: toJson_PostgresqlSpecTls(obj.tls),
    tolerations: obj.tolerations?.map((y) =>
      toJson_PostgresqlSpecTolerations(y),
    ),
    useLoadBalancer: obj.useLoadBalancer,
    users:
      obj.users === undefined
        ? undefined
        : Object.entries(obj.users).reduce(
          (r, i) =>
            i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.map((y) => y) },
          {},
        ),
    usersWithInPlaceSecretRotation: obj.usersWithInPlaceSecretRotation?.map(
      (y) => y,
    ),
    usersWithSecretRotation: obj.usersWithSecretRotation?.map((y) => y),
    volume: toJson_PostgresqlSpecVolume(obj.volume),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecAdditionalVolumes
 */
export interface PostgresqlSpecAdditionalVolumes {
  /**
   * @schema PostgresqlSpecAdditionalVolumes#name
   */
  readonly name: string;

  /**
   * @schema PostgresqlSpecAdditionalVolumes#mountPath
   */
  readonly mountPath: string;

  /**
   * @schema PostgresqlSpecAdditionalVolumes#targetContainers
   */
  readonly targetContainers?: string[];

  /**
   * @schema PostgresqlSpecAdditionalVolumes#volumeSource
   */
  readonly volumeSource: any;

  /**
   * @schema PostgresqlSpecAdditionalVolumes#subPath
   */
  readonly subPath?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecAdditionalVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecAdditionalVolumes(
  obj: PostgresqlSpecAdditionalVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    mountPath: obj.mountPath,
    targetContainers: obj.targetContainers?.map((y) => y),
    volumeSource: obj.volumeSource,
    subPath: obj.subPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecClone
 */
export interface PostgresqlSpecClone {
  /**
   * @schema PostgresqlSpecClone#cluster
   */
  readonly cluster: string;

  /**
   * @schema PostgresqlSpecClone#s3_endpoint
   */
  readonly s3Endpoint?: string;

  /**
   * @schema PostgresqlSpecClone#s3_access_key_id
   */
  readonly s3AccessKeyId?: string;

  /**
   * @schema PostgresqlSpecClone#s3_secret_access_key
   */
  readonly s3SecretAccessKey?: string;

  /**
   * @schema PostgresqlSpecClone#s3_force_path_style
   */
  readonly s3ForcePathStyle?: boolean;

  /**
   * @schema PostgresqlSpecClone#s3_wal_path
   */
  readonly s3WalPath?: string;

  /**
   * @schema PostgresqlSpecClone#timestamp
   */
  readonly timestamp?: string;

  /**
   * @schema PostgresqlSpecClone#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecClone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecClone(
  obj: PostgresqlSpecClone | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cluster: obj.cluster,
    s3_endpoint: obj.s3Endpoint,
    s3_access_key_id: obj.s3AccessKeyId,
    s3_secret_access_key: obj.s3SecretAccessKey,
    s3_force_path_style: obj.s3ForcePathStyle,
    s3_wal_path: obj.s3WalPath,
    timestamp: obj.timestamp,
    uid: obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecConnectionPooler
 */
export interface PostgresqlSpecConnectionPooler {
  /**
   * @schema PostgresqlSpecConnectionPooler#dockerImage
   */
  readonly dockerImage?: string;

  /**
   * @schema PostgresqlSpecConnectionPooler#maxDBConnections
   */
  readonly maxDbConnections?: number;

  /**
   * @schema PostgresqlSpecConnectionPooler#mode
   */
  readonly mode?: PostgresqlSpecConnectionPoolerMode;

  /**
   * @schema PostgresqlSpecConnectionPooler#numberOfInstances
   */
  readonly numberOfInstances?: number;

  /**
   * @schema PostgresqlSpecConnectionPooler#resources
   */
  readonly resources?: PostgresqlSpecConnectionPoolerResources;

  /**
   * @schema PostgresqlSpecConnectionPooler#schema
   */
  readonly schema?: string;

  /**
   * @schema PostgresqlSpecConnectionPooler#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecConnectionPooler' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecConnectionPooler(
  obj: PostgresqlSpecConnectionPooler | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    dockerImage: obj.dockerImage,
    maxDBConnections: obj.maxDbConnections,
    mode: obj.mode,
    numberOfInstances: obj.numberOfInstances,
    resources: toJson_PostgresqlSpecConnectionPoolerResources(obj.resources),
    schema: obj.schema,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinity
 */
export interface PostgresqlSpecNodeAffinity {
  /**
   * @schema PostgresqlSpecNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema PostgresqlSpecNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinity(
  obj: PostgresqlSpecNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution:
      obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        ),
      ),
    requiredDuringSchedulingIgnoredDuringExecution:
      toJson_PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecPatroni
 */
export interface PostgresqlSpecPatroni {
  /**
   * @schema PostgresqlSpecPatroni#initdb
   */
  readonly initdb?: { [key: string]: string };

  /**
   * @schema PostgresqlSpecPatroni#loop_wait
   */
  readonly loopWait?: number;

  /**
   * @schema PostgresqlSpecPatroni#maximum_lag_on_failover
   */
  readonly maximumLagOnFailover?: number;

  /**
   * @schema PostgresqlSpecPatroni#pg_hba
   */
  readonly pgHba?: string[];

  /**
   * @schema PostgresqlSpecPatroni#retry_timeout
   */
  readonly retryTimeout?: number;

  /**
   * @schema PostgresqlSpecPatroni#slots
   */
  readonly slots?: { [key: string]: { [key: string]: string } };

  /**
   * @schema PostgresqlSpecPatroni#synchronous_mode
   */
  readonly synchronousMode?: boolean;

  /**
   * @schema PostgresqlSpecPatroni#synchronous_mode_strict
   */
  readonly synchronousModeStrict?: boolean;

  /**
   * @schema PostgresqlSpecPatroni#synchronous_node_count
   */
  readonly synchronousNodeCount?: number;

  /**
   * @schema PostgresqlSpecPatroni#ttl
   */
  readonly ttl?: number;
}

/**
 * Converts an object of type 'PostgresqlSpecPatroni' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecPatroni(
  obj: PostgresqlSpecPatroni | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    initdb:
      obj.initdb === undefined
        ? undefined
        : Object.entries(obj.initdb).reduce(
          (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
          {},
        ),
    loop_wait: obj.loopWait,
    maximum_lag_on_failover: obj.maximumLagOnFailover,
    pg_hba: obj.pgHba?.map((y) => y),
    retry_timeout: obj.retryTimeout,
    slots:
      obj.slots === undefined
        ? undefined
        : Object.entries(obj.slots).reduce(
          (r, i) =>
            i[1] === undefined
              ? r
              : {
                ...r,
                [i[0]]:
                      i[1] === undefined
                        ? undefined
                        : Object.entries(i[1]).reduce(
                          // eslint-disable-next-line @typescript-eslint/no-shadow
                          (r, i) =>
                            i[1] === undefined ? r : { ...r, [i[0]]: i[1] },
                          {},
                        ),
              },
          {},
        ),
    synchronous_mode: obj.synchronousMode,
    synchronous_mode_strict: obj.synchronousModeStrict,
    synchronous_node_count: obj.synchronousNodeCount,
    ttl: obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecPostgresql
 */
export interface PostgresqlSpecPostgresql {
  /**
   * @schema PostgresqlSpecPostgresql#version
   */
  readonly version: PostgresqlSpecPostgresqlVersion;

  /**
   * @schema PostgresqlSpecPostgresql#parameters
   */
  readonly parameters?: { [key: string]: string };
}

/**
 * Converts an object of type 'PostgresqlSpecPostgresql' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecPostgresql(
  obj: PostgresqlSpecPostgresql | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    version: obj.version,
    parameters:
      obj.parameters === undefined
        ? undefined
        : Object.entries(obj.parameters).reduce(
          (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
          {},
        ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecPreparedDatabases
 */
export interface PostgresqlSpecPreparedDatabases {
  /**
   * @schema PostgresqlSpecPreparedDatabases#defaultUsers
   */
  readonly defaultUsers?: boolean;

  /**
   * @schema PostgresqlSpecPreparedDatabases#extensions
   */
  readonly extensions?: { [key: string]: string };

  /**
   * @schema PostgresqlSpecPreparedDatabases#schemas
   */
  readonly schemas?: { [key: string]: PostgresqlSpecPreparedDatabasesSchemas };

  /**
   * @schema PostgresqlSpecPreparedDatabases#secretNamespace
   */
  readonly secretNamespace?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecPreparedDatabases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecPreparedDatabases(
  obj: PostgresqlSpecPreparedDatabases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultUsers: obj.defaultUsers,
    extensions:
      obj.extensions === undefined
        ? undefined
        : Object.entries(obj.extensions).reduce(
          (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
          {},
        ),
    schemas:
      obj.schemas === undefined
        ? undefined
        : Object.entries(obj.schemas).reduce(
          (r, i) =>
            i[1] === undefined
              ? r
              : {
                ...r,
                [i[0]]: toJson_PostgresqlSpecPreparedDatabasesSchemas(i[1]),
              },
          {},
        ),
    secretNamespace: obj.secretNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecResources
 */
export interface PostgresqlSpecResources {
  /**
   * @schema PostgresqlSpecResources#limits
   */
  readonly limits?: PostgresqlSpecResourcesLimits;

  /**
   * @schema PostgresqlSpecResources#requests
   */
  readonly requests?: PostgresqlSpecResourcesRequests;
}

/**
 * Converts an object of type 'PostgresqlSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecResources(
  obj: PostgresqlSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    limits: toJson_PostgresqlSpecResourcesLimits(obj.limits),
    requests: toJson_PostgresqlSpecResourcesRequests(obj.requests),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecStandby
 */
export interface PostgresqlSpecStandby {
  /**
   * @schema PostgresqlSpecStandby#s3_wal_path
   */
  readonly s3WalPath?: string;

  /**
   * @schema PostgresqlSpecStandby#gs_wal_path
   */
  readonly gsWalPath?: string;

  /**
   * @schema PostgresqlSpecStandby#standby_host
   */
  readonly standbyHost?: string;

  /**
   * @schema PostgresqlSpecStandby#standby_port
   */
  readonly standbyPort?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecStandby' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecStandby(
  obj: PostgresqlSpecStandby | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    s3_wal_path: obj.s3WalPath,
    gs_wal_path: obj.gsWalPath,
    standby_host: obj.standbyHost,
    standby_port: obj.standbyPort,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecStreams
 */
export interface PostgresqlSpecStreams {
  /**
   * @schema PostgresqlSpecStreams#applicationId
   */
  readonly applicationId: string;

  /**
   * @schema PostgresqlSpecStreams#batchSize
   */
  readonly batchSize?: number;

  /**
   * @schema PostgresqlSpecStreams#database
   */
  readonly database: string;

  /**
   * @schema PostgresqlSpecStreams#filter
   */
  readonly filter?: { [key: string]: string };

  /**
   * @schema PostgresqlSpecStreams#tables
   */
  readonly tables: { [key: string]: PostgresqlSpecStreamsTables };
}

/**
 * Converts an object of type 'PostgresqlSpecStreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecStreams(
  obj: PostgresqlSpecStreams | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    applicationId: obj.applicationId,
    batchSize: obj.batchSize,
    database: obj.database,
    filter:
      obj.filter === undefined
        ? undefined
        : Object.entries(obj.filter).reduce(
          (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
          {},
        ),
    tables:
      obj.tables === undefined
        ? undefined
        : Object.entries(obj.tables).reduce(
          (r, i) =>
            i[1] === undefined
              ? r
              : { ...r, [i[0]]: toJson_PostgresqlSpecStreamsTables(i[1]) },
          {},
        ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecTls
 */
export interface PostgresqlSpecTls {
  /**
   * @schema PostgresqlSpecTls#secretName
   */
  readonly secretName: string;

  /**
   * @schema PostgresqlSpecTls#certificateFile
   */
  readonly certificateFile?: string;

  /**
   * @schema PostgresqlSpecTls#privateKeyFile
   */
  readonly privateKeyFile?: string;

  /**
   * @schema PostgresqlSpecTls#caFile
   */
  readonly caFile?: string;

  /**
   * @schema PostgresqlSpecTls#caSecretName
   */
  readonly caSecretName?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecTls(
  obj: PostgresqlSpecTls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretName: obj.secretName,
    certificateFile: obj.certificateFile,
    privateKeyFile: obj.privateKeyFile,
    caFile: obj.caFile,
    caSecretName: obj.caSecretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecTolerations
 */
export interface PostgresqlSpecTolerations {
  /**
   * @schema PostgresqlSpecTolerations#key
   */
  readonly key?: string;

  /**
   * @schema PostgresqlSpecTolerations#operator
   */
  readonly operator?: PostgresqlSpecTolerationsOperator;

  /**
   * @schema PostgresqlSpecTolerations#value
   */
  readonly value?: string;

  /**
   * @schema PostgresqlSpecTolerations#effect
   */
  readonly effect?: PostgresqlSpecTolerationsEffect;

  /**
   * @schema PostgresqlSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;
}

/**
 * Converts an object of type 'PostgresqlSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecTolerations(
  obj: PostgresqlSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    value: obj.value,
    effect: obj.effect,
    tolerationSeconds: obj.tolerationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecUsers
 */
export enum PostgresqlSpecUsers {
  /** BYPASSRLS */
  BYPASSRLS = 'BYPASSRLS',
  /** NOBYPASSRLS */
  NOBYPASSRLS = 'NOBYPASSRLS',
  /** CREATEDB */
  CREATEDB = 'CREATEDB',
  /** NOCREATEDB */
  NOCREATEDB = 'NOCREATEDB',
  /** CREATEROLE */
  CREATEROLE = 'CREATEROLE',
  /** NOCREATEROLE */
  NOCREATEROLE = 'NOCREATEROLE',
  /** INHERIT */
  INHERIT = 'INHERIT',
  /** NOINHERIT */
  NOINHERIT = 'NOINHERIT',
  /** LOGIN */
  LOGIN = 'LOGIN',
  /** NOLOGIN */
  NOLOGIN = 'NOLOGIN',
  /** REPLICATION */
  REPLICATION = 'REPLICATION',
  /** NOREPLICATION */
  NOREPLICATION = 'NOREPLICATION',
  /** SUPERUSER */
  SUPERUSER = 'SUPERUSER',
  /** NOSUPERUSER */
  NOSUPERUSER = 'NOSUPERUSER',
}

/**
 * @schema PostgresqlSpecVolume
 */
export interface PostgresqlSpecVolume {
  /**
   * @schema PostgresqlSpecVolume#iops
   */
  readonly iops?: number;

  /**
   * @schema PostgresqlSpecVolume#selector
   */
  readonly selector?: PostgresqlSpecVolumeSelector;

  /**
   * @schema PostgresqlSpecVolume#size
   */
  readonly size: string;

  /**
   * @schema PostgresqlSpecVolume#storageClass
   */
  readonly storageClass?: string;

  /**
   * @schema PostgresqlSpecVolume#subPath
   */
  readonly subPath?: string;

  /**
   * @schema PostgresqlSpecVolume#throughput
   */
  readonly throughput?: number;
}

/**
 * Converts an object of type 'PostgresqlSpecVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecVolume(
  obj: PostgresqlSpecVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    iops: obj.iops,
    selector: toJson_PostgresqlSpecVolumeSelector(obj.selector),
    size: obj.size,
    storageClass: obj.storageClass,
    subPath: obj.subPath,
    throughput: obj.throughput,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecConnectionPoolerMode
 */
export enum PostgresqlSpecConnectionPoolerMode {
  /** session */
  SESSION = 'session',
  /** transaction */
  TRANSACTION = 'transaction',
}

/**
 * @schema PostgresqlSpecConnectionPoolerResources
 */
export interface PostgresqlSpecConnectionPoolerResources {
  /**
   * @schema PostgresqlSpecConnectionPoolerResources#limits
   */
  readonly limits?: PostgresqlSpecConnectionPoolerResourcesLimits;

  /**
   * @schema PostgresqlSpecConnectionPoolerResources#requests
   */
  readonly requests?: PostgresqlSpecConnectionPoolerResourcesRequests;
}

/**
 * Converts an object of type 'PostgresqlSpecConnectionPoolerResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecConnectionPoolerResources(
  obj: PostgresqlSpecConnectionPoolerResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    limits: toJson_PostgresqlSpecConnectionPoolerResourcesLimits(obj.limits),
    requests: toJson_PostgresqlSpecConnectionPoolerResourcesRequests(
      obj.requests,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
  | PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
  | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preference:
      toJson_PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
  | PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
  | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeSelectorTerms: obj.nodeSelectorTerms?.map((y) =>
      toJson_PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecPostgresqlVersion
 */
export enum PostgresqlSpecPostgresqlVersion {
  /** 9.5 */
  VALUE_9_5 = '9.5',
  /** 9.6 */
  VALUE_9_6 = '9.6',
  /** 10 */
  VALUE_10 = '10',
  /** 11 */
  VALUE_11 = '11',
  /** 12 */
  VALUE_12 = '12',
  /** 13 */
  VALUE_13 = '13',
  /** 14 */
  VALUE_14 = '14',
}

/**
 * @schema PostgresqlSpecPreparedDatabasesSchemas
 */
export interface PostgresqlSpecPreparedDatabasesSchemas {
  /**
   * @schema PostgresqlSpecPreparedDatabasesSchemas#defaultUsers
   */
  readonly defaultUsers?: boolean;

  /**
   * @schema PostgresqlSpecPreparedDatabasesSchemas#defaultRoles
   */
  readonly defaultRoles?: boolean;
}

/**
 * Converts an object of type 'PostgresqlSpecPreparedDatabasesSchemas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecPreparedDatabasesSchemas(
  obj: PostgresqlSpecPreparedDatabasesSchemas | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultUsers: obj.defaultUsers,
    defaultRoles: obj.defaultRoles,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecResourcesLimits
 */
export interface PostgresqlSpecResourcesLimits {
  /**
   * @schema PostgresqlSpecResourcesLimits#cpu
   */
  readonly cpu?: string;

  /**
   * @schema PostgresqlSpecResourcesLimits#memory
   */
  readonly memory?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecResourcesLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecResourcesLimits(
  obj: PostgresqlSpecResourcesLimits | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cpu: obj.cpu,
    memory: obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecResourcesRequests
 */
export interface PostgresqlSpecResourcesRequests {
  /**
   * @schema PostgresqlSpecResourcesRequests#cpu
   */
  readonly cpu?: string;

  /**
   * @schema PostgresqlSpecResourcesRequests#memory
   */
  readonly memory?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecResourcesRequests' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecResourcesRequests(
  obj: PostgresqlSpecResourcesRequests | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cpu: obj.cpu,
    memory: obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecStreamsTables
 */
export interface PostgresqlSpecStreamsTables {
  /**
   * @schema PostgresqlSpecStreamsTables#eventType
   */
  readonly eventType: string;

  /**
   * @schema PostgresqlSpecStreamsTables#idColumn
   */
  readonly idColumn?: string;

  /**
   * @schema PostgresqlSpecStreamsTables#payloadColumn
   */
  readonly payloadColumn?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecStreamsTables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecStreamsTables(
  obj: PostgresqlSpecStreamsTables | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    eventType: obj.eventType,
    idColumn: obj.idColumn,
    payloadColumn: obj.payloadColumn,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecTolerationsOperator
 */
export enum PostgresqlSpecTolerationsOperator {
  /** Equal */
  EQUAL = 'Equal',
  /** Exists */
  EXISTS = 'Exists',
}

/**
 * @schema PostgresqlSpecTolerationsEffect
 */
export enum PostgresqlSpecTolerationsEffect {
  /** NoExecute */
  NO_EXECUTE = 'NoExecute',
  /** NoSchedule */
  NO_SCHEDULE = 'NoSchedule',
  /** PreferNoSchedule */
  PREFER_NO_SCHEDULE = 'PreferNoSchedule',
}

/**
 * @schema PostgresqlSpecVolumeSelector
 */
export interface PostgresqlSpecVolumeSelector {
  /**
   * @schema PostgresqlSpecVolumeSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresqlSpecVolumeSelectorMatchExpressions[];

  /**
   * @schema PostgresqlSpecVolumeSelector#matchLabels
   */
  readonly matchLabels?: any;
}

/**
 * Converts an object of type 'PostgresqlSpecVolumeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecVolumeSelector(
  obj: PostgresqlSpecVolumeSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_PostgresqlSpecVolumeSelectorMatchExpressions(y),
    ),
    matchLabels: obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecConnectionPoolerResourcesLimits
 */
export interface PostgresqlSpecConnectionPoolerResourcesLimits {
  /**
   * @schema PostgresqlSpecConnectionPoolerResourcesLimits#cpu
   */
  readonly cpu?: string;

  /**
   * @schema PostgresqlSpecConnectionPoolerResourcesLimits#memory
   */
  readonly memory?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecConnectionPoolerResourcesLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecConnectionPoolerResourcesLimits(
  obj: PostgresqlSpecConnectionPoolerResourcesLimits | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cpu: obj.cpu,
    memory: obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecConnectionPoolerResourcesRequests
 */
export interface PostgresqlSpecConnectionPoolerResourcesRequests {
  /**
   * @schema PostgresqlSpecConnectionPoolerResourcesRequests#cpu
   */
  readonly cpu?: string;

  /**
   * @schema PostgresqlSpecConnectionPoolerResourcesRequests#memory
   */
  readonly memory?: string;
}

/**
 * Converts an object of type 'PostgresqlSpecConnectionPoolerResourcesRequests' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecConnectionPoolerResourcesRequests(
  obj: PostgresqlSpecConnectionPoolerResourcesRequests | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cpu: obj.cpu,
    memory: obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
  | PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
  | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
  | PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
  | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecVolumeSelectorMatchExpressions
 */
export interface PostgresqlSpecVolumeSelectorMatchExpressions {
  /**
   * @schema PostgresqlSpecVolumeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * @schema PostgresqlSpecVolumeSelectorMatchExpressions#operator
   */
  readonly operator: PostgresqlSpecVolumeSelectorMatchExpressionsOperator;

  /**
   * @schema PostgresqlSpecVolumeSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PostgresqlSpecVolumeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecVolumeSelectorMatchExpressions(
  obj: PostgresqlSpecVolumeSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
  | PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
  | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * @schema PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
  | PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
  | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
  | PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
  | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * @schema PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
  | PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
  | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PostgresqlSpecVolumeSelectorMatchExpressionsOperator
 */
export enum PostgresqlSpecVolumeSelectorMatchExpressionsOperator {
  /** DoesNotExists */
  DOES_NOT_EXISTS = 'DoesNotExists',
  /** Exists */
  EXISTS = 'Exists',
  /** In */
  IN = 'In',
  /** NotIn */
  NOT_IN = 'NotIn',
}
